                    ORM

ORM (object relation mapping) – технология, которая позволяет разработчикам работать с объектами в объектно-ориентированном стиле, в то время как данные хранятся в реляционных базах данных. ORM устанавливает соответствие(отображение) между объектами и таблицами базы данных, что позволяет автоматически сохранять, извлекать, удалять и обновлять данные без явного написания SQL – запросов.
                    JPA

JPA (java persistence api) – это спецификация Java EE, которая определяет стандартный способ работы с объектами в Java- приложениях и их сохранения в реляционных базах данных. JPA предоставляет набор аннотаций и интерфейсов для работы с объектно-реляционным отображением (ORM).
	Основная цель JPA состоит в том, чтобы абстрагировать приложение от деталей конкретной базы данных и предоставить унифицированный интерфейс для работы с данными. Он позволяет разработчикам работать с объектами в объектно- ориентированном стиле, в то время как JPA- провайдеры (например, Hybernate, EclipseLink) обеспечивают преобразование этих объектов в соответствующие записи в базах данных и обратно.
	JPA не является самостоятельной реализацией, а является набором спецификаций. Для использования JPA необходимо подключить JPA- провайдер, такой как Hibernate, EclipseLink и другие, который реализует спецификацию JPA и предоставляет конкретную реализацию ORM функциональности.

                JPA основные интерфейсы
	EntittyManager является основным интерфейсом для выполнения операций по сохранению, чтению, обновлению и удалению сущностей в базах данных. Он предоставляет методы такие как persist(), find(), merge(), remove(), для выполнения этих операций, а также методы для управления транзакциями.
	EntityTransaction – интерфейс представляет транзакцию базы данных и предоставляет методы для управления транзакционными операциями, такими как begin(), commit(), rollback(). Он используется для управления границами транзакций и обеспечения согласованности изменений в базах данных.
	Query позволяет создавать и отправлять запросы к базам данных. Он предоставляет методы для создания запросов, таких как JPQL (Java Persistance Query Language) или Criteria API. Метод getResultList() и getSingleResult() используются для получения результатов запроса.
	TypedQuery – является расширением интерфейса Quey и предоставляет типизированные методы для работы с запросами. Он позволяет указать ожидаемый тип результата запроса и предоставляет более типобезопасные операции.
	CriteriaQuery – предоставляет типобезопасный способ создания запросов с использованием Criteria API. Он позволяет строить запросы в программном коде с помощью объектов-критериев, представляющих разные части запроса, такие как выборка, условия и сортировка.
	CriteriaBuilder – предоставляет методы для создания объектов критериев (CriteriaQuery, Predicate, Order и другие) и выполнения операций сравнения, логических операций и матеческих операций в запросах.


                JPA Entity
	JPA Entity (сущность) – это Java-класс, который отображается на соответствующую таблицу в базе данных. JPA использует аннотации для определения сущности и её отображения на таблицу.

Может в себе содержать:
	Value types:
-	Базовые типы
-	вложенные типы
-	колллекции
Entity Types


                Требования Entity
1)	Entity должен быть отмечен аннотацией Entity или описан в XML файле конфигурации JPA,
2)	Entity класс должен содержать public или protected конструктор без аргументов (также может иметь конструктор с аргументами)
3)	Entity класс должен быть классом верхнего уровня (top level class)
4)	Entity класс не может быть enum или интерфейсом
5)	Entity класс не может быть финальным классом (final class)
6)	Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistence final methods or persistence final instance variables)
7)	Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например, через удалённый интерфейс (through a remote interface), он также должен реализовывать Serializable интерфейс
8)	Поля Entity класса должны быть доступны напрямую только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity-классе)
9)	Entity-класс должен содержать первичный ключ, то есть атрибут или группу атрибутов, которые уникально определяют запись этого Entity класса в базе данных.

Entity основные аннотации

1. @Entity применяется к классу и указывает, что данный класс является
сущностью. Он должен иметь конструктор без аргументов и быть открытым для наследования или наследоваться от другого класса.

2. @Table применяется к классу и используется для указания имени таблицы, к которой будет отображаться сущность. Если имя таблицы не указано, то оно будет соответсвовать имени класса.

3. @Id применяется к полю или геттеру/сеттеру и указывает, что это поле является первичным ключом сущности.

4. @GeneratedValue - используется в сочетании с @Id и указывает, что знаечние первичного ключа будет генерироваться автоматически

5. @Column - применяется к полю или геттеру/сеттеру и используется для указания отображения поля на столбец таблицы. Она также позволяет указать различные атрибуты, такие как имя столбца, тип данных, ограничения и др.

6. @OneToMany и @ManyToOne - используются для определения отнощений "один ко многим" и "многие ко одному".

7. @ManyToMany - применяется для определения отношений "многие ко многим" между сущностями

8. @JoinColumn - используется в сочетании с @ManyToOne или @OneToOne и указывает столбец, который используется для связи между сущностями.


                JPA состояния

1. Transient - сущность находится в состоянии transient, когда она только создана или не связана с текущим персистентным контекстом. В этом состоянии сущность не отслеживается Jpa и не имеет соответсвующей записи в базе данных.

2. Persistent (or Managed) - сущность находится в состоянии persistent, когда она ассоциирована с персистентным контекстом JPA. В этом состоянии изменения, внесённые в сущность, отслеживаются JPA, и они могут быть автоматически синхронизированны с базой данных во время фиксации транзакции.

3. Detached - сущность находится в состоянии deteched, когда она была отсоединена от персистентного контекста JPA. Это может произойти, например, когда транзакция, в рамках которой была получена сущность, завершилась, или явно вызван метод отсоединения. В этом состоянии изменения в сущности не отслеживаются JPA, и они не автоматически синхронизируются с базой данных.

4. Removed - сущностьнаходится в состоянии removed, когда она была помечена для удаления. В этом состоянии JPA удалит соответствующую запись из базы данных при фиксации транзакции.


                Hybernate

Hybernate- это одна из самых популярных ORM (object- Relational Mapping) библиотек для языка программирования Java. он предоставляет удобное и мощные инструменты для работы с базами данных, позволяя разработчкиам взаимодействовать с данными в объектно=ориентированном стиле, на вдаваясь в детали работы с SQL.

HQL (Hibernate Query Language) - объектно-ориентированный язык запросов, подобный SQL, но работающий с объектами сущностей. HQL позволяет выполнять запросы, которые оперирут объектами и их свойствами, а не непосредственно таблицами базы данных.

String hql = "FROM User WHERE aga > :age";
Query query = session.createQuery(hql);
query.setParameter("age", 18);
List<User> users = query.list();


                Criteria Query

Criteria API позволяет создавать запросы с использованием критериев и условий, а не явно писать SQL или HQL запросы. Он предоставляет типобезопасыне и более гибкие возможности для создания запросов.

CriteriaBuilder builder = session.getCriteriaBuilder();
CriteriaQuery<User> criteriaQuery = builder.createQuery(User.class);
Root<User> root = criteriaQuery.from(User.class);
criteriaQuery.select(root).where(builder.greaterThan(root.get("age"), 18));
List<User> users = session.createQuery(criteriaQuery).hetResultList();


                Native SQL Query

Hybernate также позволяет выполнять нативные SQL запросы, которые напрямую работают с таблицами базы данных.

String sql = "SELECT * FROM users WHERE age > :age";
Query query = session.createNativeQuery(sql, User.class);
query.setParameter("age", 18);
List<User> users = query.getResultList();


                Named Query

Можно определить именованные запросы в классе сущности или в файле XML конфигурации Hibernate. Затем вы можете вызывать эти именованные запросы, используя их уникальное имя

@NamedQueries((
    @NamedQuery(name = "User.findByAge", query = "FROM User WHERE age > :age")
))
public class User {
    //...
}

Query query = session.getNamedQuery("User.findByAge");
query.setParameter("age", 18);
List<User> users = query.list();


                    Типы связей

OneToOne, OneToMany, ManyToOne, ManyToMany,
ОДносторонние, двунаправленные

One-to-One

Односторонняя
@Entity
public class User{
    @OneToOne
    @JpinColumn(name = "addressId")
    private Address adress;
    //...
}
@Entity
public class Adress{
    //...
}


Двунаправленная
@Entity
public class User {
    @OneToOne (mappedBy = "user");
    private UserProfile userProfile;
    //....
}
@Entity
public class userProfile {
    @OneToOne
    @JoinColumn("name" = "userId")
    private User user;
    //...
}


One-to-Many

Односторонняя
@Entity
public class User {
    @OneToMany
    @JoinColumn (name = "userId")
    private List<Order> orders;
    //...
}

Двунаправленная
@Entity
public class User {
    @OneToMany(mappedBy = "user")
    private List<Order> orders;
    //...
}
@Entity
public class Order {
    @ManyToOne
    @JoinColumn (name = "userId")
    private User user;
    //...
}


Many-to-Many
@Entity
public class User {
    @ManyToMany
    @JoinTable(name = "userRole",
        joinColumns = @JoinColumn(name = "userId"),
        inverseJoinColumns = @JoinColumn(name = "roleId"))
    private List<Role> roles;
        //...
}
@Entity
public class Rols {
    @ManyToMany(mappedBy = "roles")
    private List<User> users;
    //...
}


Hibernate наследование

1) Одна таблица для каждого класса
2) Одна таблица для каждого класса через Union
3) Единая таблица для всей иерархии классов
4) Одна таблица для каждого класса с использованием соединений (JOIN)


            Hibernate cache

1. Кэш первого уровня(First-level Cache) - кэш первого уровня в Hibernate является встроенным кэшем, который автоматически активируется и управляется Hibernate для каждой текущей сессии (Session). Он хранит объекты сущностей, полученных в рамках текущей сессии, и предотвращает повторные запросы к базе данных при обращении к одному и тому же объекту в текущей сессии.
2. Кэш второго уровня (Second level Cache) - кэш второго уровня в Hibernate является встроенным кэшем, который доступен для всех сессий и сохраняется между ними. Он может быть настроен для хранения повторно используемых данных сущностей или запросов, чтобы избежать повторных обращений к базе данных. Для работы с кэшем второго уровня необходимо использовать сторонние поставщики кэша, такие как Ehcache, Infinispan, Hazelcast и другие.
3. Кэш запросов (Query Cache) - кэш запросов в Hibernate позволяет кэшировать результатов запросов. Это особенно полезно для запросов, которые выполняются часто и возвращают стабильные результаты. Кэш запросов может быть включен и натсроен для конкретных зарпросов с использованием соответсвующей настройки.


            Проблема N+1
Проблема N+1 является распространенной проблемой в Hibernate (и других ORM-фрейморках), которая возникает при загрузке связанных данных из базы данных. Эта проблема может привести к неэффективной работе и снижению производительности приложения.
    Проблема N+1 возникает в следующих случаях:
1. Загрузка связанных коллекций: когда вы загружаете сущность, которая имеет связанную коллекцию (например, One-toMany или Many-toMany отношение), и для каждого элемента в коллекции выполняется отдельный запрос к базе данных. Это может привести к большому количеству запросов, что замедляет работу приложения.
2. Ленивая загрузка: если вы используете ленивую загрузку (lazy loading) для связанных данных, то при обращении к этим данным Hibernate выполняет дополнительные запросы для загрузки связанных объектов, что может привести к N+1 проблеме

- Join fetch
- Entity graph
- @FetchMode (SUBSELECT, JOIN)
- @BatchSize



                ACID/Isolations
                JDBS

База данных - это упорядоченный набор структурированной информации или данных, которые обычно хранятся в электронном виде в компьютерной системе. База данных обычно управляется системой управления базами данных (СУБД). Данные вместе с СУБД, а также приложения, которые с ними связаны, называются системой баз данных, или, для краткаости, просто базой данных.


            Relational Databases
Реляционнная база данных - база данных, основанная на реляционной модели данных. Это набор данных с предопределёнными связями между ними. Это данные организованы в виде набора таблиц, состоящих из столбцов и строк. В таблицах хранится информация об объектах, представленных в базе данных.
Плюсы:
- Данные легко структурируются по категориям.
- Ваши данные единообразны по вводу, значению и просты в навигации.
- Между точками данных можно легко определить отнощения.
- Сама структура реляции хорошо подходит для обеспечения транзакционности (ACID)

Нормальная форма - требование, предъвляемое к структуре таблиц в теории реляционных баз данных для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц).

1НФ 1) в таблице не должно быть дублирующих строк
    2) в каждой ячейке таблицы хранится атомарное значение
    3) в столбце хранятся данныее одного типа

2НФ 1) 1НФ
    2) таблица должна иметь первичный ключ
    3) все неключевые столбцы должны зависеть от полного первичного ключа

3НФ 1) 2НФ
    2) в таблице должна отсутствовать транзитивная зависимость неключевых столбцов


                Transactions
Транзакцией называется множество операций, выполняемое приложением. которое переводит базу данных из одг/ного корректного состояния в другое корректное состояние (согласованность) при условии, что транзакция выполнена полностью (атомарность) и без помех со стороны других транзакций (изоляция).


            ACID
Atomicity (атомарность) - выражается в том, что транзакция должна быть выполнена в целом или не выполнена вовсе.

Consistency (согласованность) - гарантирует, что по мере выполнения транзакций, данные переходят из одного согласованного состояния в другое, то есть транзакция не может разрушить взаимной согласованности данных.

Isolation (изолированность) - означает, что конкурирующие за доступ к БД транзакции физически обрабатываются последовательно, изолированно друг от друга, но для пользователей это выглядит, как будто они выполняются параллельно.

Durability (долговечность) - устойчивость к ошибкам - если транзакция завершена успешно, то те изменения в данныз, которые были ею произведены, не могут быть потеряны на при каких обстоятельствах.


        Isolation
Потерянное обоновление - ситуация. когда при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется.

"Грязное" чтение - чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится).

Неповторяющееся чтение - ситуация, когда при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными.

Чтение "фантомов" - ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка даёт разные множества строк.

Уровень изоляции        Фантомное чтение        Неповторяющееся чтение          "Грязное" чтение        Потерянное обновление

Serializable                    +                           +                           +                        +

Repeatable READ                 -                           +                           +                        +

READ COMMITED                   -                           -                           +                        +

READ UNCOMMITED                 -                           -                           -                        +



            JDBC

JDBC - это платформенно независимый промышленный стандарт взаимодействия java приложений с реалиционными базами данных. Впервые был включен в состав JDK 1.1 d 1997 году. JDBC управляет:
    - подключением к базе данных
    - выдачей запросов и комманд
    - обработкой данных, полученных из базы

Пакет JDBC состоит из двух главных компонентов:
1. API (программного интерфейса), который поддерживает связь между Java- приложением и менеджером JDBC;
2. Драйвера JDBC, которые поддерживают связь между менеджером JDBC и драйвером базы данных.

Соединение с базой устанавливается по особому URL. При этом разработчику нужно знать специфику конкретной базы - API выступает в качестве посредника между базой и приложением. Это упрощает как процесс создания приложения, так и переход на базу данных другого типа.

Этапы подключения к базе данныз
1. Установка базы данных (или выбор облачного сервиса), к которому нужно получить доступ.
2. Подключение библиотеки JDBC.
3. Проверка нахождения необходимого драйвера JDBC в classpath.
4. Установление соединения с базой данных с помощью библиотеки JDBC.
5. Использование установленного соединения для выполнения команд SQL.
6. Закрытие соединения после окончания сеанса.


- Driver manager - управляет списком драйверов БД. Каждый запрос на соединение требует соответсвующего драйвера. Первое совпадение даёт соединение.

- Driver - отвечает за связь с БД. Работать с ним приходится крайне редко. Вместо этого используется DriverManager, которые управляют объектами этого типа.

- Connection - интерфейс, обеспечивающий методы работы с БД. Все взаимодействия с БД происходят исключительно через Connection.

- Statement - используется для SQL - запросов

- ResultSet - экземпляры этого элемента содержат данные, которые были получены в результате выполнения SQL- запроса. Он работает как итератор и "пробегает" по полученным данным.


        Statement
Используется для выполнения обычных SQL запросов. Вы не можете передавать параметры в SQL-запрос во время выполнения с помощью этого интерфейса. Этот интерфейс предпочтительнее двух других интерфейсов, если вы выполняете конкретный запрос SQL только один раз. Производительность этого интерфейса также намного ниже по сравнению с двумя другими интерфейсами. В большинстве случаев интерфейс Statement используется для операторов DDL, таких как Create, Alter, DROP и т.д.


        PreparedStatement
Используется для выполнения динамических или параметизированных SQL- запросов. PreparedStatement расширяет интерфейс Statement. Можно передать параметры в SQL- запрос во время выполнения, используя этот интерфейс. Рекомендуется использовать PreparedStatement, если определённый SQL-зпрос выполняется несколько раз. Он обеспечивает лучшую производительность, чем интерфейс Statement. Потому что PreparedStatement предварительно скомпилирован, а план щвпроса создаётся только один раз, независимо от того, сколько раз выполняется этот запрос.


        CallableStatement
используется для выполнения хранимыз процедур. CallableStatement расширяет PreparedStatement. Используя CallableStatement, можно передавать хранимым 3 типа параметров: IN- используется для передачи значений хранимой проедуре, OUT- используется для хранения результата, возвращаемого хранимой процедурой, а IN OUT - действует как параметр IN и OUT. Перед вызовом хранимой процедуры необходимо зарегистрировать параметры OUT с помощью метода redisterOutParameter() CallableStatement. Производительность этого интерфейса выше, чем у двух других интерфейсов. Потому что он вызывает хранимые процедуры, которые уже скомпилированы и хранятся на сервере базы данных.


            Statement                           PreparedStatement                                       CallableStatement
используется для выполнения обычных         Используется для выполнения параметизированных          используется для хранимых процедур
SQL-запросов.                               или динамических SQL- запросов


Предпочтительно, когда конкретный           Предпочтительно, когда конкретный SQL-запрос            предпочтительно, когда должны выполняться
SQL-запрос должен выполняться только        должен выполняться несоклько раз                        хранимые процедуры
один раз


Нельзя передавать параметры в SQL-          Можно передавать парметры в SQL-запрос вовремя          можно передавать 3 параметра, IN, OUT и
запрос                                      выполнения                                              IN OUT


В основном используется для                 Используется для любого типа SQL-запросов,              ипользуется для выполнения хранимых процедур
операторов DDL, таких как CREATE,           которые должны выполняться несколько раз                и функций
ALTER, DROP и т.д.


Производительность интерфейса               производительность лучше, чем у Statement               производетльность интерфейса высока
очень низкая                                для многократного повторения одного и того
                                            же запроса


