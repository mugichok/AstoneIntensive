    Многопоточность - свойство платформы или приложения, состоящее в том, что процесс, порожденный в операционной системе,
может состоять из нескольких потоков, выполняющихся "параллельно". то есть без предписанного порядка во времени

Процесс - это экземпляр выполняемой программы, а также текущее значение счетчиков команд, регистров и переменных.

Поток - это основная единица, которой операционная система выделяет время процесса

    Отличие многопоточности от параллелизма в том, что параллелизм предусматривает использование отдельного ядра цпу под каждый поток,
а в многопоточночти на отдельном ядре цпу может работать несколько потоков

Базовый способ создания потока - new Thread() через наследование и переопределение методов,
Другой способ - имплементировать функционального интерфейса

    Методы управления потоком:

void start() - запуск потока
void join()/join(mills) - ожидание завершения потока
void sleep(int) - приостановка потока на заданное время
void interrupt() - прерывание выполнения потока
void wait()/wait(mills) - приостановка потока, пока другой поток не вызовет метод notify()
void notify() - "пробуждение" отдельного потока, ожидающего "сигнала"
boolean isAlive() - проверка, выполняется ли поток
boolean isDeamon() - проверяет, является ли поток "deamon"

    Состояния потока:
New: когда вы создаёте новый объект Thread(), но ещё не запустили его с помощью метода Start(), поток находится в состоянии
"New". Это означает, что поток был создан, но ещё не началось его выполнение.
Runnable: после вызова метода start() он переходит в соcтояние "Runnable". В этом состоянии поток готов к запуску, но в данный
момент может быть не запущен, поскольку планировщик ОС ещё не запланировал его.
Running: как только поток запланирован ОС, он переходит в состояние "Running"(Выполняется). В это время код потока активно выполняется
и потребляет время процессора.
Blocked: Работающий поток может перейти в состояние Blocked(заблокирован), также известное как Waiting или Blocked on I/O.
В этом состоянии он ожидает ресурса, например, блокировки или ввода пользователя. Поток не выполняет свой код, но он сразу будет считаться
Runnable, как только ресурс станет доступным.
Terminated: поток переходит в состояние Terminated(завершён) или Dead, когда он завершит своё выполнение или после генерации исключения,
вызывающего внезапное завершение потока. Если поток находится в этом состоянии, его нельзя перезапустить.

    Синхронизация данных. Монитор
    Мьютекс(Mutual Exclusion Object) - это специальный объект для синхронизации потоков. Он прикреплён к каждому объекту в java.
Любой поток должен захватить мьютекс для доступа к ресурсу, который находится под его защитой. Контролируют доступ только у одному ресурсу.
Для управления мьютекс в java используется монитор.
    Монитор - это механизм Java для обеспечения безопасности при работе с общими ресурсами(Например, переменными или объектами) из нескольких
потоков.

    Синхронизация данных. Встроенные мониторы.
Каждый объект в Java имеет встроенный монитор(intrisic lock). Его работа основана на использовании ключевого слова synchronized и блоков
синхронизации. Когда поток захватывает этот монитор, второй поток ожидает(принцип светофора). Но монитор связан со всем классом.

    Синхронизация данных. Внешние мониторы.
В java существует концепция внешних мониторов. Функциональность таких мониторов заключена в классы блокировок пакета java.util.concurrent.locks
и реализуют интерфейс lock.
Организация блокировок в общем случае довольно проста, для получения блокировки вызывается метод lock(), а после окончания работы с общими
ресурсами вызывается метод unlock(), который снимает блокировку.
Объект Condition позволяет управлять блокировкой.
Как правило, для работы с блокировками используется класс ReentrantLock из пакета java.util.concurrent.locks.

            Различия между synchronized и ReentrantLock

                      ReentrantLock                                                                     Synchronized

Гибкость                предоставляет более гибкий инструмент по работе с блокировками             Предоставляет простой и удобный способ синхронизации
использования           по сравнению с Synchronized. Он обеспечивает возможность                   методов или блоков, но не поддерживает дополнительные
                        использования нескольких условных переменных, попыток получить             функции, такие как условные переменные
                        блокировку с таймаутом и прерываниями, что делает его более мощным
                        инструментом для управления потоками.

Возможность захвата     позволяет потоку захватывать несколько блокировок одновременно,            можно использовать только один монитор за раз
нескольких              что может быть полезно в нескольких сценариях синхронизации
блокировок


Управление              предоставляет более точный контроль над блокировкой благодаря              обрабатывается автоматически JVM, и у нас меньше
блокировкой             методам live lock(), unlock(), tryLock() и т.д., которые могут             возможностей для явного контроля
                        быть полезными в сложных сценариях

Поддержка               может работать в режиме "справедливой" блокировки, где блокировка          нет встроенной поддержки справедливости
справедливости          будет предоставлена самому долго ожидающему потоку. Это поможет
                        избежать проблемы голодания(starvation), когда некоторые потоки
                        постоянно вытесняются другими

Улучшенная              В некоторых случаях ReentrantLock может дать лучшую производительность
производительность      по сравнению с synchronized. Однако это зависит от конкретных условий
                        и оптимизации JVM, поэтому результат может варьироваться


    Синхронизация данных. Принцип Семафора
Семафоры - это переменные, которые используются для контроля доступа к общему ресурсу.
Существуют бинарные семафоры и семафоры со счётчиком.
1. Бинарные впускают только 1 поток (synchronized)
2. Со счётчиком впускают определённое количество потоков и контролируют только количество входов.

В java семафоры представлены классом Semaphore.
Для управления доступом к ресурсу семафор использует счётчик, представляющий количество разрешений. Если значение счётчика больше нуля,
то поток получает доступ к ресурсу, при этом счётчик уменьшается на единицу. После окончания работы с ресурсом поток освобождает семафор
, и счётчик увеличивается на единицу. Если же счётчик равен нулю, то поток блокируется и ждёт, пока не получит разрешение от семафора.
- Установить количество разрешений для доступа к ресурсу можно с помощью констурукторов;
- Для получения одоного или нескольких разрешений у семафора надо вызвать метод acquire(). После вызова метода, пока поток не получит
разрещение, он блокируется.
- После окончания работы с ресурсом полученное ранее разрешение надо освободить с помощью метода release()

    Передача данных между потоками.
В java для передачи данных между потоками используется Exchanger()
Он является типизировнным и типизируется в соответствии с передаваемым типом данных.
Обмен данными производится с помощью единственного метода этого класса exchange().
В качетве параметра передаёт типизированный буфер обмена.

    Синхронизация данных типовые проблемы.
DeadLock - ситуация, когда 2 и более потока бесконечно "ждут" ресурс, который занят другим потоком.

LiveLock (динамическая блокировка) - система не "застревает" (как при DeadLock), а занимается бесполезной работой, её состояние
постоянно меняется, но, тем не менее, она зациклилась и не производит никако йполезной работы.

Starvation - это результат процесса, который не может получить регулярный доступ к общим ресурсам, необходимым для выполнения задачи,
и, следовательно, не может добиться какого-то прогресса.

DataRace(состояние гонки) возникает, когда поведение программы зависит от относительного времени событий в нескольких потоках. Это часто
приводит к нередсказуемым и неверным результатам, поскольку потоки могут мешать доступу к данным друг другу.

    Синхронизация данных. Состояние гонки.
В современном компьютере может быть несколько процессоров, которые напрямую не управляются JVM, и нет возможности определить, в каком ядре
в конечном итоге будет выполняться поток.
Когда процессор выполняет код, он считывает данные из основной памяти. Однако современные процессоры имеют различные кэши для более
быстрого доступа к памяти. L1 Cache, L2 Cache, L3 Cache.
Следствием совместного ипользования потоками пространства памяти процесса является одновременное считывание данных из переменной,
так и записывание в неё.
Эта возможность даёт более быстрый доступ к памяти, но имеет неприятный эффект в виде состояния гонки, которое порождает несогласованность
данных в программе.

    Синхронизация данных. Volatile
Для рещения проблемы состояния гонки моэно использовать ключеввое слово volatile, которое применимо только для полей объекта, но не для
локальных переменных.
Если поле является final, то в volatile нет необходимости. Это происходит, потому что final-поля никогда не меняются, а значит не могут
создать озвученных ранее проблем.
Также нужно иметь в виду, что, если ссылка на объект используется в качестве поля и является volatile, то это не означает, что содержимое
объекта также является volatile.
    Преимущества использования:
- Поток всегда считавает данные из основнйо памяти
- Процессор никогда не кэшируует значения, что исключает возникновение проблемы видимости
- Компилятору сообщается, что значение переменной может быть изменено в любое время и разделено между несколькими потоками, поэтому ему
рекомендууется не потимизировать его, что предотвращает возникновение состояния гонки.
    Недостатки:
- Снижение производительности
- препятствие оптимизациям в процессе выполнения

    Синхронизация данных. Атомарные операции
Позволяют обеспечить потокобезопасность и синхронизацию без использования блокировок. Блокировки часто могут приводить к проблемам
производительности, таким как пропусная производительность и масштабируемость, а также трудностям в отладке и анализе кода.
Атомарные операции прежставляют эффективные, неблокирующие альтернативы, которые могут существенно улучшить производительность и
устойчивость многопоточных приложений.

    Механизмы CAS и FAA
CAS(Compare and swap) и FAA(Fetch and Add) являются атомарными операциями, предназначенными для обеспечения потокобезопасности и
синхронизации в многопоточных приложениях.
CAS позволяет сравнить значение переменной с ожидаемым значением и, если сравнение проходит успешно, атомарно обновить его
FAA представляет атомарное инкрементирование или декрементирование переменных, что делает его идеальным для счётчиков и агрегаторов.

CAS - это атомарная операция, которая сравнивает значение переменной с ожидаемым значением и, если они совпадают, обновляет переменную
новым значением. Весь процесс выполнения CAS является атомарным, то есть не может быть прерван другими потоками или операциями.

Операция CAS имеет три операнда: адрес ячейки памяти (V), ожидаемое старое значение (A) и новое значение (B)
Процессор атомарно обновляет адрес ячейки(V), если значение в ячейке памяти совпадает с ожидаемым старым значением (A), в противном
случае изменения не фиксируется.
В любом случае будет возвращено значение, которое существовало до запроса.
Некоторые варианты метода CAS возвращают информацию об успешности операции, а не текущее значение.

FAA - это атомарная операция, которая считывает текущее значение переменной, увеличивает его на заданное число и затем возвращает старое
значение переменной. FAA является одним из основных примитивов для реализации атомарных операций в многопоточных приложениях.
FAA включает в себя два операнда: адрес ячейки памяти(V) и значение (S), на которое необходимо увеличить старое значение, хранящееся
по адресу памяти (V).
Таким образом, FAA можно представить следующим образом: извлечь занчение по ууказанному адресу(V) и временно сохранить его.
Затем записать в указанный адрес(V) предварительно сохраненное значение, увеличенное на значение второго операнда(S).
Вышеупомянутые операции реализованы атомарно и выполняются на аппаратном уровне.

Пакет java.util.concurrent.* использует под капотом механизм CAS. Для работы с примитивами используются классы AtomicInteger, AtomicLong и другие.
Методы incrementAndGet() - CAS
Методы getAndAdd() и addAndGet() - FAA
Для выполнения атомарных операций на полях объектов - AtomicReferenceFieldUpdater


                                    Thread pools
    Thread pools(пулы потоков) - фундаментальная концепция многопоточного программирования, которая используется для эффективного управления
потоками и их повторного использования.

Пул потоков - набор предварительно инициализированных рабочих потоков, готовых одновременно выполнять задачи. Их применение устраняет
накладные задачи на создание и удаление потоков для каждой задачи, что может быть довольно дорогостоящей процедурой.

Основные понятия:
Worker Threads (рабочие потоки). Пул потоков содержит фиксированное или переменное количество рабочих потоков.
Task Queue(очередь задач). Задачи отправляются в очередь задач. Рабочие поптоки постоянно отслеживают этй очередь на наличие ожидающих задач
Task Submission(Отправка задач). Вы отправляете задачи в пул потоков, и пул назанчает их доступными рабочим потокам. Если доступных потокв
нет, задачи ждут в очереди, пока попток не освободится.
Reuse(повторное использование). После того, как рабочий поток завершит задачу, его можно повторно использовать для другой задачи,
устраняя накладные расходы на создание и уничтожение потока.


                                    Executor Framework
    Для управления пулами потоков иподдержания абстракции высокого уровня в java используется Executor Framework. он содержит набор
интерфейсов и классов для одновременного выполнения задач с использованием пулов потоков. Основным интерфейсом на плтформе Executor
является одноименный интерфейс Executor.
    Основные компоненты фрейворка:
Executor: это корневой интерфейс платформы Executor. он определяет единственный метод execute(Runnable command) для отправки задач
на выполнение
ExecutorService: это подинтерфейс Executor, который добавляет такие функции, как отправка задачи с возвращемыми значениями с помощью
submit(), отмена задач и многое другое.
ThreadPoolExecutor: это наиболее часто используемая реализация интерфейса ExecutorService. Она позволяет создавать и настраивать пулы потоков
с указанным количеством ядер и максимальным количеством потоков, а также различными другими настройками.
Executors: это служебный класс, который предоставляет фабричные методы для создания различных типов экземпляров ExecutorService, таких как
пулы потоков фиксированного размера, кэшированные пулы потоков и запланированные пулы потоков.

Преимущества и использование:
- Эффективное управление ресурсами. Пулы потоков управляют созданием, повторным использованием и прекращением использования потоков,
обеспечивая более эффективное использование системных ресурсов.
- Контроль над количеством над количеством потоков. Вы можете контролировать количество потоков в пуле, что помогает предотвратить истощение
ресурсов в системе.
- Поддержка приоритета задач. Пулы потоков часто поддерживают приоритет задач, что позволяет назначать задачам разные приоритеты.
- Абстракция задач. Пулы потоков абстрагируют детали потоковой ообработки, позволяя вам сосредоточиться на задачах, которые необходимо
выполнять одновременно.
- Улучшенная скорость реагирования. Позволяет избегать накладных расходов на создание потоков, пулы потоков могут улучшить скорость
реагирования приложений.

Ключевые реализации Executor Framework

SingleThreadPoolExecutor имеет только 1 пул в потоке
FixedThreadPool создаёт фиксированное количество потоков в пуле. Чаще всего это количество процессоров-1
ScheduledThreadPool позволяет выполнять задачи на регулярной основе или с отложенным стартом
CacheThreadPool количество потоков в пуле не ограничено и может быть увеличено при высокой нагрузке. Если нагрузка низкая, то количество
потоков уменьшается.


                                Fork-Join Framework
    Fork-Join Poll - реализация ExecutorService, предоставляющая мощные возможности для эффективной работы с параллельными и рекурсивными
задачами. Он основан на алгоритме work-stealing, что позволяет более эффективно распределить задачи между потоками.

Особенности:
    - Используется принцип разделяй и властвуй, т.е. задачи должны быть независимы друг от друга(например, сумма элементов массива,
    поиск максимального числа в массиве и т.д.)
    - Work-stealing потоки воруют работу друг у друга
    - Создаётся фиксированный пул потоков(обчыно 4 количество CPU)
Для работы используются интерфейсы Recursivetask<T> или RecursiveAction и переопределяемый метод compute().


                                 Concurrent интерфейсы Callable, Future
    При работе многопоточного приложения часто необходиом получение от потока результат его деятельности в виде некоторого объекта.
Эту задачу можно решить с помощью интерфейсов Callable<V> и Future<V>.
Своместное использование двух реализаций данных интерфейсов позволяет получить резултат в виде некоторго объекта.

Интерфейс Callable<V> очень похож на Runnable. объекты, реализующие данные интрефейсы, использу.тся другим потоком. Однако, в отличие
от Runnable, интерфейс Callable использует generic для определения типа возвращаемого объекта.
В Callable метод call(), описывающий действие потока во время выполнения. Аналог Runnable метод run().

Интерфейс Future<V> также, как и интерфейс Callable, использует generic'и. Метод интерфейса можно использовать для проверки завершения
работы потока, ожидания завершения и получения результата. Результат выполнения может быть получен методом get(), если поток завершил
работу. Прервать выполнение задачи можно методом cancel().
Дополнительные методы позволяют поределить завершение задачи: нормальное или прерванное. Если задача завершена, то прервать её уже невозможно.

cancel(boolean mayInterruptIfRunning) попытка заверщения задачи
V get() ожидание(при необходимости) завершения задачи, после чего можно будет получить результат
V get(long timeout, TimeUnit unit) ожидание(при необходимости) завершения задачи в течение определенного времени, после чего можно будет
получить результат
isCancelled() вернет true, если выполнение задачи будет прервано прежде завершения
isDone() вернет true, если задача завершена

    Интерфейс Future<T>. Ограничения
1. оно может быть завершено вручную
2. Future не уведомляет вас о своём завершении и значит невозможно можете выполнять дальнейшие действия с будущим результатом без блокировки
3. Несколько фьючерсов не могут быть соединены вместе в цепочку
4. Вы не можете объединить несоклько фьючерсов вместе
5. Future Api нет никакой конструкции для обработки исключений

    Интерфейс CompletableFuture<V>
CompletableFuture - это расширение Future, введенное в Java 8, которое предоставляет более мощные возможности для работы с асинхронными
операциями.
Основные отличия от Future заключается в их возможностях и гибкости.
- предоставляет более высокий уровень абстракции и более широкий набор методов для работы с асинхронными операцями.
- позволяет комбинировать и композировать несколько асинхронных операций, управлять их завершениям и обрабатывать исключения.
- предосталяет множество методов для выполнения различных операций над результатом асинхронной операции. Например, вы можете применить
функцию к результату операции, скомбинировать результаты нескольких опреаций, обработать исключения и т.д.
- предоставляет методы для управления потоком выполнения операций, таких как thenApply, thenCompose, thenCombine и другие.


