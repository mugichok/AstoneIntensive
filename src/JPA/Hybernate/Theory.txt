ORM

ORM (object relation mapping) – технология, которая позволяет разработчикам работать с объектами в объектно-ориентированном стиле, в то время как данные хранятся в реляционных базах данных. ORM устанавливает соответствие(отображение) между объектами и таблицами базы данных, что позволяет автоматически сохранять, извлекать, удалять и обновлять данные без явного написания SQL – запросов.
JPA

JPA (java persistence api) – это спецификация Java EE, которая определяет стандартный способ работы с объектами в Java- приложениях и их сохранения в реляционных базах данных. JPA предоставляет набор аннотаций и интерфейсов для работы с объектно-реляционным отображением (ORM).
	Основная цель JPA состоит в том, чтобы абстрагировать приложение от деталей конкретной базы данных и предоставить унифицированный интерфейс для работы с данными. Он позволяет разработчикам работать с объектами в объектно- ориентированном стиле, в то время как JPA- провайдеры (например, Hybernate, EclipseLink) обеспечивают преобразование этих объектов в соответствующие записи в базах данных и обратно.
	JPA не является самостоятельной реализацией, а является набором спецификаций. Для использования JPA необходимо подключить JPA- провайдер, такой как Hubernate, EclipseLink и другие, который реализует спецификацию JPA и предоставляет конкретную реализацию ORM функциональности.

JPA основные интерфейсы
	EntittyManager является основным интерфейсом для выполнения операций по сохранению, чтению, обновлению и удалению сущностей в базах данных. Он предоставляет методы такие как persist(), find(), merge(), remove(), для выполнения этих операций, а также методы для управления транзакциями.
	EntityTransaction – интерфейс представляет транзакцию базы данных и предоставляет методы для управления транзакционными операциями, такими как begin(), commit(), rollback(). Он используется для управления границами транзакций и обеспечения согласованности изменений в базах данных.
	Query позволяет создавать и отправлять запросы к базам данных. Он предоставляет методы для создания запросов, таких как JPQL (Java Persistance Query Language) или Criteria API. Метод getResultList() и getSingleResult() используются для получения результатов запроса.
	TypedQuery – является расширением интерфейса Quey и предоставляет типизированные методы для работы с запросами. Он позволяет указать ожидаемый тип результата запроса и предоставляет более типобезопасные операции.
	CriteriaQuery – предоставляет типобезопасный способ создания запросов с использованием Criteria API. Он позволяет строить запросы в программном коде с помощью объектов-критериев, представляющих разные части запроса, такие как выборка, условия и сортировка.
	CriteriaBuilder – предоставляет методы для создания объектов критериев (CriteriaQuery, Predicate, Order и другие) и выполнения операций сравнения, логических операций и матеческих операций в запросах.
JPA Entity
	JPA Entity (сущность) – это Java-класс, который отображается на соответствующую таблицу в базе данных. JPA использует аннотации для определения сущности и её отображения на таблицу.

Может в себе содержать:
	Value types:
-	Базовые типы
-	вложенные типы
-	колллекции
Entity Types

Требования Entity
1)	Entity должен быть отмечен аннотацией Entity или описан в XML файле конфигурации JPA,
2)	Entity класс должен содержать public или protected конструктор без аргументов (также может иметь конструктор с аргументами)
3)	Entity класс должен быть классом верхнего уровня (top level class)
4)	Entity класс не может быть enum или интерфейсом
5)	Entity класс не может быть финальным классом (final class)
6)	Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistence final methods or persistence final instance variables)
7)	Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например, через удалённый интерфейс (through a remote interface), он также должен реализовывать Serializable интерфейс
8)	Поля Entity класса должны быть доступны напрямую только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity-классе)
9)	Entity-класс должен содержать первичный ключ, то есть атрибут или группу атрибутов, которые уникально определяют запись этого Entity класса в базе данных.

Entity основные аннотации

1. @Entity применяется к классу и указывает, что данный класс является
сущностью. Он должен иметь конструктор без аргументов и быть открытым для наследования или наследоваться от другого класса.

2. @Table применяется к классу и используется для указания имени таблицы, к которой будет отображаться сущность. Если имя таблицы не указано, то оно будет соответсвовать имени класса.

3. @Id применяется к полю или геттеру/сеттеру и указывает, что это поле является первичным ключом сущности.

4. @GeneratedValue - используется в сочетании с @Id и указывает, что знаечние первичного ключа будет генерироваться автоматически

5. @Column - применяется к полю или геттеру/сеттеру и используется для указания отображения поля на столбец таблицы. Она также позволяет указать различные атрибуты, такие как имя столбца, тип данных, ограничения и др.

6. @OneToMany и @ManyToOne - используются для определения отнощений "один ко многим" и "многие ко одному".

7. @ManyToMany - применяется для определения отношений "многие ко многим" между сущностями

8. @JoinColumn - используется с сочетании с @ManyToOne или @OneToOne и указывает столбец, который используется для связи между сущностями.

JPA состояния

1. Transient - сущность находится в состоянии transient, когда она только создана или не связана с текущим персистентным контекстом. В этом состоянии сущность не отслеживается Jpa и не имеет соответсвующей записи в базе данных.

2. Persistent (or Managed) - сущность находится в состоянии persistent, когда она ассоциирована с персистентным контекстом JPA. В этом состоянии изменения, внесённые в сущность, отслеживаются JPA, и они могут быть автоматически синхронизированны с базой данных во время фиксации транзакции.

3. Detached - сущность находится в состоянии deteched, когда она была отсоединена от персистентного контекста JPA. Это может произойти, например, когда транзакция, в рамках которой была получена сущность, завершилась, или явно вызван метод отсоединения. В этом состоянии изменения в сущности не отслеживаются JPA, и они не автоматически синхронизируются с базой данных.

4. Removed - сущностьнаходится в состоянии removed, когда она была помечена для удаления. В этом состоянии JPA удалит соответствующую запись из базы данных при фиксации транзакции.


Hybernate

Hybernate- это одна из самых популярных ORM (object- Relational Mapping) библиотек для языка программирования Java. он предоставляет удобное и мощные инструменты для работы с базами данных, позволяя разработчкиам взаимодействовать с данными в объектно=ориентированном стиле, на вдаваясь в детали работы с SQL.

HQL (Hibernate Query Language) - объектно-ориентированный язык запросов, подобный SQL, но работающий с объектами сущностей. HQL позволяет выполнять запросы, которые оперирут объектами и их свойствами, а не непосредственно таблицами базы данных.

String hql = "FROM User WHERE aga > :age";
Query query = session.createQuery(hql);
query.setParameter("age", 18);
List<User> users = query.list();


Criteria Query

Criteria API позволяет создавать запросы с использованием критериев и условий, а не явно писать SQL или HQL запросы. Он предоставляет типобезопасыне и более гибкие возможности для создания запросов.

CriteriaBuilder builder = session.getCriteriaBuilder();
CriteriaQuery<User> criteriaQuery = builder.createQuery(User.class);
Root<User> root = criteriaQuery.from(User.class);
criteriaQuery.select(root).where(builder.greaterThan(root.get("age"), 18));
List<User> users = session.createQuery(criteriaQuery).hetResultList();


Native SQL Query

Hybernate также позволяет выполнять нативные SQL запросы, которые напрямую работают с таблицами базы данных.

String sql = "SELECT * FROM users WHERE age > :age";
Query query = session.createNativeQuery(sql, User.class);
query.setParameter("age", 18);
List<User> users = query.getResultList();


Named Query

Можно определить именованные запросы в классе сущности или в файле XML конфигурации Hibernate. Затем вы можете вызывать эти именованные запросы, используя их уникальное имя

@NamedQueries((
    @NamedQuery(name = "User.findByAge", query = "FROM User WHERE age > :age")
))
public class User {
    //...
}

Query query = session.getNamedQuery("User.findByAge");
query.setParameter("age", 18);
List<User> users = query.list();


Типы связей

OneToOne, OneToMany, ManyToOne, ManyToMany,
ОДносторонние, двунаправленные

One-to-One

Односторонняя
@Entity
public class User{
    @OneToOne
    @JpinColumn(name = "addressId")
    private Address adress;
    //...
}
@Entity
public class Adress{
    //...
}


Двунаправленная
@Entity
public class User {
    @OneToOne (mappedBy = "user");
    private UserProfile userProfile;
    //....
}
@Entity
public class userProfile {
    @OneToOne
    @JoinColumn("name" = "userId")
    private User user;
    //...
}


One-to-Many

Односторонняя
@Entity
public class User {
    @OneToMany
    @JoinColumn (name = "userId")
    private List<Order> orders;
    //...
}

Двунаправленная
@Entity
public class User {
    @OneToMany(mappedBy = "user")
    private List<Order> orders;
    //...
}
@Entity
public class Order {
    @ManyToOne
    @JoinColumn (name = "userId")
    private User user;
    //...
}


Many-to-Many
@Entity
public class User {
    @ManyToMany
    @JoinTable(name = "userRole",
        joinColumns = @JoinColumn(name = "userId"),
        inverseJoinColumns = @JoinColumn(name = "roleId"))
    private List<Role> roles;
        //...
}
@Entity
public class Rols {
    @ManyToMany(mappedBy = "roles")
    private List<User> users;
    //...
}


Hibernate наследование

1) Одна таблица для каждого класса
2) Одна таблица для каждого класса через Union
3) Единая таблица для всей иерархии классов
4) Одна таблица для каждого класса с использованием соединений (JOIN)


Hibernate cache

1. Кэш первого уровня(First-level Cache) - кэш первого уровня в Hibernate является встроенным кэшем, который автоматически активируется и управляется Hibernate для каждой текущей сессии (Session). Он хранит объекты сущностей, полученных в рамках текущей сессии, и предотвращает повторные запросы к базе данных при обращении к одному и тому же объекту в текущей сессии.
2. Кэш второго уровня (Second level Cache) - кэш второго уровня в Hibernate является встроенным кэшем, который доступен для всех сессий и сохраняется между ними. Он может быть настроен для хранения повторно используемых данных сущностей или запросов, чтобы избежать повторных обращений к базе данных. Для работы с кэшем второго уровня необходимо использовать сторонние поставщики кэша, такие как Ehcache, Infinispan, Hazelcast и другие.
3. Кэш запросов (Query Cache) - кэш запросов в Hibernate позволяет кэшировать результатов запросов. Это особенно полезно для запросов, которые выполняются часто и возвращают стабильные результаты. Кэш запросов может быть включен и натсроен для конкретных зарпосов