package src.Streams.Streams;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Random;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/*
Основные свойства потоков:
1. Декларативность: потоки в Java описывают, что должно быть сделано, а не конкретный способ выполнения
2. Ленивость: потоки не выполняют никакой работы, пока не будет вызвана терминальная операция
3. Одноразовость - после того, как терминальная операция была вызвана на потоке, этот поток больше не может быть использован.
Если необходимо применить другую операцию к данным, потребуется новый поток
4. Параллельность: несмотря на то, что потоки в java выполняются последовательно, их можно распараллелить.

последовательность выполнения стримов может быть описана следующим образом:
1. Источник данных
2. Выполнение преобразований
3. Сохранение результата в новую структуру данных

Компоненты стримов:
1. источник - откуда приходят данные. Это может быть массив, коллекция, файл, генератор или любой другой источник данных
2. Операции - преобразовывают и/или обрабатывают данные
3. Поток - последовательность элементов, подлежащая параллельной ии/ли последовательной обработке
4. Пайплайн - последовательность операций в потоке, применяемая к данным
5. Терминал - место выхода данных из потока. терминальная операция означает окончание обработки потока и возвращает результат

 */
public class Main {
    public static void main(String[] args) {
        List<Integer> list = List.of(1,2,3,4,5,6);

        int sum = list.stream().reduce(0, Integer::sum);
        System.out.println("Сумма: " + sum);

        // способы создания стримов: 1 из набора значений
//        Stream<String> fromValues = Stream.of("f", "v", "ce", "ve");

        // из массива
//        Stream<String> fromArray = Arrays.stream(new String[]{"x", "y", "g"});

        //из файла (каждая строка в файле будет отдельным элементом в стриме)
//        Stream<String> fromFile = Files.lines(Paths.get("InputFileReader.txt"));

        // из строки
//        IntStream fromString = "123455666".chars();

        // помощью Stream.builder()
//        Stream<Object> fromStreamBuilder = Stream.builder().add("a").add("g").add("g").build();

        // с помощью iterate( (бесконечный)
//        Stream<Integer> fromIterate = Stream.iterate(1,n->n+1);

        //с помощью generate(бесконечный)
//        Stream<String> fromGenerate = Stream.generate(()->"0");

        Stream.generate(()-> new Random().nextInt(100))
                .limit(12)
                .skip(5)
                .forEach(System.out::println);
    }

    /*
     класс Collectors и его методы:
     toLost(),toCollection(), toSet() - представляют стрим в виде списка, коллекции или множества
     toConcurrentMap(), toMap() - позволяют преобразовать стрим в map
     averagingInt(), averagingDouble(), averagingLong() - возвращают среднее значение
     summingInt(), summingDouble(), ummingLong() - возвращают сумму
     summarizingInt(), summarizingDouble(), summarizingLong() - возвращают SummaryStatistics с разными агрегатными значениями
     partitioningBy() - разделяет коллекцию на две части по соответствию условию и возвращает их как Map<Boolean, List>
     groupingBy() - разделяет коллекцию на несколько частей и возвращает Map<N, List<T>>
     mapping() - дополнительные преобразования значений для сложных Collect- ов
     */

    /*
    Optional- утилитарный класс, целями которого являются повышение null-safety и читаемости кода при работе со ссылками,
    значения которых может быть null. Главная цель - замена null- значений, благодаря чему должна повышаться безопасность и читаемость кода

    Optional - это контейнер. Он может содержать объект некоторого типа T, а может быть пустым

    Методы создания:
    of() - создаёт optional из не null-значения. При передаче значения типа null будет выброшено исключение
    ofNullable() - создаёт optional из значения, которое может быть null. Если значение не null, то будет создан optional
    со значением, иначе- пустой optional
    empty() - создаёт пустой optional

    Методы преобразования
    map - преобразует элементы в соответствии с логикой функции, переданной в аргумент
    flatMap()  декларирует, что переданная функция должна возвращать другой optional, пустой или содержащий новое значение,
    пустой или содержащий новое значение
    or() позволяет пустой optional преобразовать в непустой

    Методы проверки:
    isPresent() возвращает true, если объект optional содержит значение, false - если нет
    isEmpty() антипод isPresent()

    Методы получения значений:
    get() получает значение объекта optional, если он не пустой, в ином случае выбрасывает исключение
    orElse() возвращает значение объекта optional или значение, переданное в качестве аргумента, которое может быть null
    orElseGet() возвращает "запасное" значение, если объект optional пустой
    orElseThrow() возвращает значение объекта типа optional или выбрасывает исключение, если не переданы аргументы

    Условные методы
    ifPresent() обрабатывает optional с помощью Consumer. Выполняется, если optional выбрасывает значение
    ifPresentOrElse() аналогичен
     */
}
